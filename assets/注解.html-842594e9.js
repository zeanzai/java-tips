import{_ as l,W as t,X as o,a0 as e,a1 as i,$ as n,Y as r,C as s}from"./framework-713583e3.js";const d="/java-tips/assets/1699851181809-7a4f4158.png",c="/java-tips/assets/1699851187149-11ca33eb.png",u={},p=r(`<h2 id="_1-背景" tabindex="-1"><a class="header-anchor" href="#_1-背景" aria-hidden="true">#</a> 1. 背景</h2><p>JDK 提供了一套完整的代码运行的规范和实现【比如，jvm 中方法区中完成字节码的准备工作，之后在堆中完成引用的链接等，最后在栈上进行运行】，但是有些复杂的业务场景下需要自行控制代码的运行，比如想要完成子类对父类方法的重写，那么就需要在子类的重写方法上做标记，标记“这是对父类方法的重写”，不是别的什么方法，只有这样 jvm 才知道“哦，这是子类的实际应该运行的方法，而不是调用父类的方法”。</p><p>针对这种场景，最开始的解决方案是 XML 方式，即在项目中引入 xml 配置文件，在配置文件中做一下标识，然后就可以达到上面说的这种效果。</p><p>但随着项目越来越庞大，xml 配置文件变得越来越复杂，维护成本也越来越高，于是，人们又提出注解的配置方式。</p><h2 id="_2-注解-vs-xml" tabindex="-1"><a class="header-anchor" href="#_2-注解-vs-xml" aria-hidden="true">#</a> 2. 注解 vs XML</h2><ul><li>XML 会随着项目的膨胀，导致维护成本越来越高，效率较低；但这种方式耦合度较低；</li><li>注解方式耦合度较高，但是效率很高；</li></ul><h2 id="_3-注解的基本原理" tabindex="-1"><a class="header-anchor" href="#_3-注解的基本原理" aria-hidden="true">#</a> 3. 注解的基本原理</h2><blockquote><p>补充： .java 元代码文件需要通过编译之后生成 .class 字节码文件，之后 .class 字节码通过加载过程申请运行时的内存空间。 .java 元代码文件 编译 成 .class 字节码文件的过程，称为编译期； .class 字节码加载到内存空间的过程，称为加载期； 最终内存上的运行过程，称为运行期（runtime）；</p></blockquote><ul><li>我们可以把注解理解为： 注解只是一种标识代码实际意义的特殊代码，它强依赖于解析它的代码，如果没有解析它的代码，它可能连自然语言的注释还不如，因此理解注解关键点在于注解的解析代码。</li><li>解析注解的代码的实现方式有两种，一种是编译期直接扫描，另一种是运行期反射。 <ul><li>二者的不同在于解析逻辑作用的时机不同。</li><li>编译期直接扫描可以理解为，解析代码作用在编译期，即 jdk 会根据注解的实际内容生成实际可运行的 .class 字节码文件；</li><li>运行期反射可以理解为，解析代码作用在运行期，利用的是 Java 的反射机制，在运行期调用实际的代码逻辑时，通过生成一个目标注解的代理类，来执行注解代码的解析逻辑；</li></ul></li></ul><h2 id="_4-元注解" tabindex="-1"><a class="header-anchor" href="#_4-元注解" aria-hidden="true">#</a> 4. 元注解</h2><blockquote><p>元注解： 描述注解的注解。</p></blockquote><ul><li>@Target：注解的作用目标，方法上/类上/变量上 <ul><li>使用：@Target(value = {ElementType.FIELD})</li><li>ElementType 是一个枚举值： <ul><li>ElementType.TYPE：允许被修饰的注解作用在类、接口和枚举上</li><li>ElementType.FIELD：允许作用在属性字段上</li><li>ElementType.METHOD：允许作用在方法上</li><li>ElementType.PARAMETER：允许作用在方法参数上</li><li>ElementType.CONSTRUCTOR：允许作用在构造器上</li><li>ElementType.LOCAL_VARIABLE：允许作用在本地局部变量上</li><li>ElementType.ANNOTATION_TYPE：允许作用在注解上</li><li>ElementType.PACKAGE：允许作用在包上</li></ul></li></ul></li><li>@Retention：注解的生命周期，决定使用那种解析方式 <ul><li>使用： @Retention(value = RetentionPolicy.RUNTIME)</li><li>RetentionPolicy 是一个枚举值： <ul><li>RetentionPolicy.SOURCE：当前注解编译期可见，解析逻辑不会写入 class 文件</li><li>RetentionPolicy.CLASS：类加载阶段丢弃，解析逻辑会写入 class 文件</li><li>RetentionPolicy.RUNTIME：永久保存，解析逻辑可以反射获取</li></ul></li></ul></li><li>@Documented：注解是否应当被包含在 JavaDoc 文档中</li><li>@Inherited：是否允许子类继承该注解</li></ul><h3 id="_4-1-jdk-内建注解" tabindex="-1"><a class="header-anchor" href="#_4-1-jdk-内建注解" aria-hidden="true">#</a> 4.1. JDK 内建注解</h3><ul><li>@Override</li><li>@Deprecated</li><li>@SuppressWarnings</li></ul><h3 id="_4-2-示例" tabindex="-1"><a class="header-anchor" href="#_4-2-示例" aria-hidden="true">#</a> 4.2. 示例</h3><blockquote><p>「java.lang.annotation.Annotation」接口中有这么一句话，用来描述『注解』。 The common interface extended by all annotation types 所有的注解类型都继承自这个普通的接口（Annotation）。</p></blockquote><p>所以注解的本质就是一个继承了 Annotation 接口的接口。</p><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code>// 这是注解 @Override 的定义，
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {

}


// 其实它本质上就是：
public interface Override extends Annotation{
    
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+d+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><figure><img src="'+c+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>设置一个虚拟机启动参数，用于捕获 JDK 动态代理类。</p><blockquote><p>-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true</p></blockquote><p>最后我们再总结一下整个反射注解的工作原理：</p><ol><li>首先，我们通过键值对的形式可以为注解属性赋值，像这样：@Hello（value = &quot;hello&quot;）。</li><li>接着，你用注解修饰某个元素，编译器将在编译期扫描每个类或者方法上的注解，会做一个基本的检查，你的这个注解是否允许作用在当前位置，最后会将注解信息写入元素的属性表。</li><li>然后，当你进行反射的时候，虚拟机将所有生命周期在 RUNTIME 的注解取出来放到一个 map 中，并创建一个 AnnotationInvocationHandler 实例，把这个 map 传递给它。</li><li>最后，虚拟机将采用 JDK 动态代理机制生成一个目标注解的代理类，并初始化好处理器。</li></ol><p>那么这样，一个注解的实例就创建出来了，它本质上就是一个代理类，你应当去理解好 AnnotationInvocationHandler 中 invoke 方法的实现逻辑，这是核心。一句话概括就是，通过方法名返回注解属性值。</p><h2 id="自定义注解" tabindex="-1"><a class="header-anchor" href="#自定义注解" aria-hidden="true">#</a> 自定义注解</h2><p>比如 设置一个 分布式锁 的注解，参考：</p>',27),h={href:"https://github.com/CoderLeixiaoshuai/java-eight-part/blob/master/docs/java/annotation/%E6%83%B3%E8%87%AA%E5%B7%B1%E5%86%99%E6%A1%86%E6%9E%B6%E4%B8%8D%E4%BC%9A%E5%86%99Java%E6%B3%A8%E8%A7%A3%E5%8F%AF%E4%B8%8D%E8%A1%8C.md",target:"_blank",rel:"noopener noreferrer"},m=e("h2",{id:"_5-参考",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_5-参考","aria-hidden":"true"},"#"),i(" 5. 参考")],-1),v={href:"https://juejin.cn/post/6844903636733001741",target:"_blank",rel:"noopener noreferrer"};function _(E,b){const a=s("ExternalLinkIcon");return t(),o("div",null,[p,e("p",null,[e("a",h,[i("java-eight-part/docs/java/annotation/想自己写框架不会写Java注解可不行.md at master · CoderLeixiaoshuai/java-eight-part"),n(a)])]),m,e("p",null,[e("a",v,[i("JAVA 注解的基本原理"),n(a)])])])}const f=l(u,[["render",_],["__file","注解.html.vue"]]);export{f as default};
