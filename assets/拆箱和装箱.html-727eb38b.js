import{_ as n,W as a,X as s,Y as t}from"./framework-713583e3.js";const e={},p=t(`<h2 id="_1-导引" tabindex="-1"><a class="header-anchor" href="#_1-导引" aria-hidden="true">#</a> 1. 导引</h2><h3 id="_1-1-问题引入" tabindex="-1"><a class="header-anchor" href="#_1-1-问题引入" aria-hidden="true">#</a> 1.1 问题引入</h3><p>我们知道，Java中int变量存在于jvm的静态区中，在系统之中它的存在形式很简单，就是一个简单的内存块，里面放了一个具体的数字，而Integer则是一个具体的对象，里面不光有具体的数字，还有一些具体的操作方法。早期的Java版本中，要想对int的数据进行对象化操作时，就必须要先把int转化为Integer对象才能够进行操作。例如：在Java1.5中，集合（Collections）不能直接放入int类型的数据，因为集合中要求存放的必须是对象。所以，为了节省由原始类型转化为对象类型的人工成本，也为了迎合Java中一切都是对象的思想，Java后续的版本中就引入了自动拆箱和自动装箱的机制。</p><h2 id="_2-概念" tabindex="-1"><a class="header-anchor" href="#_2-概念" aria-hidden="true">#</a> 2. 概念</h2><h3 id="_2-1-基本数据类型和封装数据类型" tabindex="-1"><a class="header-anchor" href="#_2-1-基本数据类型和封装数据类型" aria-hidden="true">#</a> 2.1 基本数据类型和封装数据类型</h3><p>基本数据类型主要有8种，他们分别是：</p><table><thead><tr><th><strong>基本数据类型(primitive)</strong></th><th>byte</th><th>short</th><th>int</th><th>long</th><th>float</th><th>double</th><th>char</th><th>boolean</th></tr></thead><tbody><tr><td><strong>占用内存大小</strong></td><td>1字节</td><td>2字节</td><td>4字节</td><td>8字节</td><td>4字节</td><td>8字节</td><td>1 字节</td><td>未知</td></tr><tr><td><strong>默认值</strong></td><td>(byte)0</td><td>(short)0</td><td>0</td><td>0L</td><td>0.0f</td><td>0.0d</td><td>\\u000</td><td>false</td></tr><tr><td><strong>封装数据类型(wrapper)</strong></td><td>Byte</td><td>Short</td><td>Integer</td><td>Long</td><td>Float</td><td>Double</td><td>Character</td><td>Boolean</td></tr></tbody></table><p>二者之间的区别：</p><table><thead><tr><th>基本数据类型</th><th>封装数据类型</th></tr></thead><tbody><tr><td>1. 基本类型</td><td></td></tr></tbody></table><ol start="2"><li>是面向机器底层的数据结构，不需要实例化</li><li>在内存中就是一个简单的变量，没有具体的操作方法 | 1. 引用类型</li><li>是Java对象，<strong>可能</strong>需要进行实例化</li><li>有具体的操作方法 |</li></ol><h3 id="_2-2-拆箱和装箱" tabindex="-1"><a class="header-anchor" href="#_2-2-拆箱和装箱" aria-hidden="true">#</a> 2.2 拆箱和装箱</h3><p>装箱就是将基本数据类型转化为封装数据类型的过程，其主要使用了valueOf()函数将对象的值转化为封装类型的对象；同时，拆箱过程中，就使用intValue()、doubleValue()等函数，将对象的值转化为基本数据类型的值。</p><hr><h2 id="_3-适用场景与不适用场景" tabindex="-1"><a class="header-anchor" href="#_3-适用场景与不适用场景" aria-hidden="true">#</a> 3. 适用场景与不适用场景</h2><h3 id="_3-1-适用场景" tabindex="-1"><a class="header-anchor" href="#_3-1-适用场景" aria-hidden="true">#</a> 3.1 适用场景</h3><p>在Java1.5之前都需要手动的进行基本数据类型到封装类型之间的转化，Java1.5之后就可以实现自动的拆箱和装箱操作了。</p><h3 id="_3-1-1-赋值" tabindex="-1"><a class="header-anchor" href="#_3-1-1-赋值" aria-hidden="true">#</a> 3.1.1 赋值</h3><p>自动拆箱和自动装箱的一个应用场景就是赋值操作。</p><p>如下面代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//before autoboxing</span>
<span class="token class-name">Integer</span> iObject <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Int</span> iPrimitive <span class="token operator">=</span> iObject<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">//after java5</span>
<span class="token class-name">Integer</span> iObject <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">//autobxing - primitive to wrapper conversion</span>
<span class="token keyword">int</span> iPrimitive <span class="token operator">=</span> iObject<span class="token punctuation">;</span> <span class="token comment">//unboxing - object to primitive conversion</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Java编译器帮我们自动完成装箱和拆箱操作。</p><h3 id="_3-1-2-方法调用" tabindex="-1"><a class="header-anchor" href="#_3-1-2-方法调用" aria-hidden="true">#</a> 3.1.2 方法调用</h3><p>另外一个应用场景就是方法调用，在方法调用的过程中，方法会根据具体的参数类型来进行拆箱和装箱操作。如下所示：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Integer</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> iParam<span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;autoboxing example - method invocation i: &quot;</span> <span class="token operator">+</span> iParam<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> iParam<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//autoboxing and unboxing in method invocation</span>
<span class="token function">show</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//autoboxing</span>
<span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//unboxing because return type of method is Integer</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-2-不适用场景" tabindex="-1"><a class="header-anchor" href="#_3-2-不适用场景" aria-hidden="true">#</a> 3.2 不适用场景</h2><h3 id="_3-2-1-重载" tabindex="-1"><a class="header-anchor" href="#_3-2-1-重载" aria-hidden="true">#</a> 3.2.1 重载</h3><p>什么情况下不适用，就是重载场景中。先看一个场景：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;method with primitive argument&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;method with wrapper argument&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>

<span class="token comment">//calling overloaded method</span>
<span class="token class-name">AutoboxingTest</span> autoTest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AutoboxingTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
autoTest<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//no autoboxing</span>
<span class="token class-name">Integer</span> iValue <span class="token operator">=</span> value<span class="token punctuation">;</span>
autoTest<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>iValue<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//no autoboxing</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在重载的过程中，如果多个同名函数中，一个使用基本数据类型作为参数，一个使用封装数据类型作为参数，那么在使用过程中不会发生重载，传递什么类型的参数，就使用什么类型的函数。</p><h3 id="_3-2-2-对象之间的比较" tabindex="-1"><a class="header-anchor" href="#_3-2-2-对象之间的比较" aria-hidden="true">#</a> 3.2.2 对象之间的比较</h3><p>这是一个比较容易出错的地方，”“可以用于原始值进行比较，也可以用于对象进行比较，当用于对象与对象之间比较时，比较的不是对象代表的值，而是检查两个对象是否是同一对象，这个比较过程中没有自动装箱发生。进行对象值比较不应该使用”“，而应该使用对象对应的equals方法。看一个能说明问题的例子。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AutoboxingTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment">// Example 1: == comparison pure primitive – no autoboxing</span>
        <span class="token keyword">int</span> i1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;i1==i2 : &quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

        <span class="token comment">// Example 2: equality operator mixing object and primitive</span>
        <span class="token class-name">Integer</span> num1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// autoboxing</span>
        <span class="token keyword">int</span> num2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;num1 == num2 : &quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>num1 <span class="token operator">==</span> num2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

        <span class="token comment">// Example 3: special case - arises due to autoboxing in Java</span>
        <span class="token class-name">Integer</span> obj1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// autoboxing will call Integer.valueOf()</span>
        <span class="token class-name">Integer</span> obj2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// same call to Integer.valueOf() will return same</span>
                            <span class="token comment">// cached Object</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;obj1 == obj2 : &quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>obj1 <span class="token operator">==</span> obj2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

        <span class="token comment">// Example 4: equality operator - pure object comparison</span>
        <span class="token class-name">Integer</span> one <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// no autoboxing</span>
        <span class="token class-name">Integer</span> anotherOne <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;one == anotherOne : &quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>one <span class="token operator">==</span> anotherOne<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>值得注意的是第三个小例子，这是一种极端情况。obj1和obj2的初始化都发生了自动装箱操作。但是处于节省内存的考虑，JVM会缓存-128到127的Integer对象。因为obj1和obj2实际上是同一个对象。所以使用”==“比较返回true。</p><hr><h2 id="_4-使用中需要注意的问题" tabindex="-1"><a class="header-anchor" href="#_4-使用中需要注意的问题" aria-hidden="true">#</a> 4. 使用中需要注意的问题</h2><ol><li>在程序中，如果写了需要不断拆箱和装箱的操作代码，会造成额外的系统开销，增加垃圾回收的压力</li><li>在自动拆箱和自动装箱过程中要注意默认值的问题（在拆箱过程中，如果使用了未初始化的对象，执行obj.xxxValue就会报NullPointerException异常）</li></ol><hr><h2 id="_5-总结" tabindex="-1"><a class="header-anchor" href="#_5-总结" aria-hidden="true">#</a> 5. 总结</h2><p>Java中的拆箱和装箱机制便利了程序开发人员，减少了程序开发人员的工作量，使得基本数据类型和封装数据类型之间有一个高效快捷的桥梁。但是凡事都有两面性，在使用过程中一定要注意初始值问题和适用场景问题，切不可以随意任意使用。</p>`,39),o=[p];function c(i,l){return a(),s("div",null,o)}const r=n(e,[["render",c],["__file","拆箱和装箱.html.vue"]]);export{r as default};
